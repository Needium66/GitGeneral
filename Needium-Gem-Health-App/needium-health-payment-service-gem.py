####################################################
#Payment Service Deployment
#######################################################################################################
#Python code for the NINC Payment microservice, which handles payment processing within the application
########################################################################################################
# The Code:
########################################################################################################
# payment_service.py

from fastapi import FastAPI, HTTPException, status
from pydantic import BaseModel, Field
import boto3
import os
import uuid
import json
import logging
from datetime import datetime
from typing import Optional, List, Dict, Any, Union
from enum import Enum

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# --- Configuration ---
AWS_REGION = os.getenv("AWS_REGION", "us-east-1")
PAYMENTS_TABLE_NAME = os.getenv("PAYMENTS_TABLE_NAME", "NINCPayments")
# Assume a third-party payment gateway integration.
# In a real scenario, this would be the actual API endpoint for Stripe, PayPal, etc.
# For demonstration, we'll simulate it.
THIRD_PARTY_PAYMENT_GATEWAY_URL = os.getenv("THIRD_PARTY_PAYMENT_GATEWAY_URL", "https://api.thirdpartypayment.com/process")

# AWS KMS Key ID for encrypting sensitive tokens (e.g., payment gateway tokens)
# This should be an alias (alias/ninc-payment-encryption-key) or ARN of a customer-managed KMS key.
KMS_KEY_ID = os.getenv("KMS_KEY_ID", "alias/ninc-payment-encryption-key")

# --- Enums ---
class PaymentStatus(str, Enum):
    PENDING = "pending"
    SUCCESS = "success"
    FAILED = "failed"
    REFUNDED = "refunded"

class PaymentMethod(str, Enum):
    CREDIT_CARD = "credit_card"
    DEBIT_CARD = "debit_card"
    PAYPAL = "paypal"
    APPLE_PAY = "apple_pay"

# --- Pydantic Models for Data Validation and Serialization ---

class PaymentRequest(BaseModel):
    """
    Model for initiating a new payment.
    Note: Raw sensitive payment data (e.g., full credit card number) should NOT
    be handled directly by this microservice. It should come tokenized from the frontend
    or be handled directly by the payment gateway.
    For this example, 'payment_token' is a placeholder for a token generated by the client-side SDK
    of a payment gateway.
    """
    patient_id: str = Field(..., description="ID of the patient making the payment.")
    amount: float = Field(..., gt=0, description="Amount of the payment.")
    currency: str = Field("USD", description="Currency of the payment (e.g., USD, EUR).")
    description: str = Field(..., description="Description of the payment (e.g., 'Consultation fee').")
    appointment_id: Optional[str] = Field(None, description="Optional: ID of the associated appointment.")
    pharmacy_order_id: Optional[str] = Field(None, description="Optional: ID of the associated pharmacy order.")
    payment_method: PaymentMethod = Field(..., description="Method of payment.")
    # This token would be generated by a client-side SDK (e.g., Stripe.js) and securely
    # passed to the backend. The backend never sees the raw card details.
    payment_token: str = Field(..., description="Secure token from payment gateway's client-side SDK.")

class PaymentResponse(BaseModel):
    """
    Model for returning payment transaction details.
    """
    transaction_id: str
    patient_id: str
    amount: float
    currency: str
    description: str
    payment_method: PaymentMethod
    status: PaymentStatus
    appointment_id: Optional[str] = None
    pharmacy_order_id: Optional[str] = None
    gateway_response_id: Optional[str] = Field(None, description="ID returned by the third-party payment gateway.")
    created_at: datetime
    updated_at: datetime

# --- AWS Service Clients ---

def get_dynamodb_client():
    """
    Initializes and returns a DynamoDB client.
    """
    try:
        return boto3.client('dynamodb', region_name=AWS_REGION)
    except Exception as e:
        logger.error(f"Error initializing DynamoDB client: {e}")
        raise

def get_kms_client():
    """
    Initializes and returns an KMS client.
    """
    try:
        return boto3.client('kms', region_name=AWS_REGION)
    except Exception as e:
        logger.error(f"Error initializing KMS client: {e}")
        raise

# --- Service Class for Data Operations ---

class PaymentService:
    """
    Handles payment operations, interacts with DynamoDB, and simulates payment gateway interaction.
    Encrypts sensitive tokens using KMS.
    """
    def __init__(self):
        self.dynamodb = get_dynamodb_client()
        self.kms = get_kms_client()
        self.table_name = PAYMENTS_TABLE_NAME
        self.kms_key_id = KMS_KEY_ID

    def _dynamodb_item_to_payment_response(self, item: Dict[str, Any]) -> PaymentResponse:
        """
        Converts a DynamoDB item dictionary to a PaymentResponse Pydantic model.
        """
        try:
            return PaymentResponse(
                transaction_id=item['transaction_id']['S'],
                patient_id=item['patient_id']['S'],
                amount=float(item['amount']['N']),
                currency=item['currency']['S'],
                description=item['description']['S'],
                payment_method=PaymentMethod(item['payment_method']['S']),
                status=PaymentStatus(item['status']['S']),
                appointment_id=item.get('appointment_id', {}).get('S'),
                pharmacy_order_id=item.get('pharmacy_order_id', {}).get('S'),
                gateway_response_id=item.get('gateway_response_id', {}).get('S'),
                created_at=datetime.fromisoformat(item['created_at']['S']),
                updated_at=datetime.fromisoformat(item['updated_at']['S'])
            )
        except KeyError as e:
            logger.error(f"Missing key in DynamoDB item: {e}. Item: {item}")
            raise ValueError(f"Invalid DynamoDB item format: {e}")
        except Exception as e:
            logger.error(f"Error converting DynamoDB item to PaymentResponse: {e}. Item: {item}")
            raise

    def _encrypt_data(self, plaintext: str) -> str:
        """
        Encrypts plaintext data using AWS KMS.
        Returns the ciphertext as a base64 encoded string.
        """
        try:
            response = self.kms.encrypt(
                KeyId=self.kms_key_id,
                Plaintext=plaintext.encode('utf-8')
            )
            # Boto3 returns bytes for CiphertextBlob, convert to base64 string for storage
            return response['CiphertextBlob'].decode('base64')
        except Exception as e:
            logger.error(f"Error encrypting data with KMS: {e}")
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Failed to encrypt sensitive data.")

    def _decrypt_data(self, ciphertext_b64: str) -> str:
        """
        Decrypts base64 encoded ciphertext using AWS KMS.
        Returns the original plaintext string.
        """
        try:
            # Decode base64 string back to bytes
            ciphertext_blob = ciphertext_b64.encode('base64')
            response = self.kms.decrypt(
                CiphertextBlob=ciphertext_blob
            )
            return response['Plaintext'].decode('utf-8')
        except Exception as e:
            logger.error(f"Error decrypting data with KMS: {e}")
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Failed to decrypt sensitive data.")

    def process_payment(self, payment_request: PaymentRequest) -> PaymentResponse:
        """
        Processes a payment by simulating interaction with a third-party gateway
        and recording the transaction in DynamoDB.
        """
        transaction_id = str(uuid.uuid4())
        current_time = datetime.now()
        payment_status = PaymentStatus.PENDING # Initial status

        # --- Step 1: Encrypt sensitive token before potentially storing or processing ---
        # While the full token ideally isn't stored, for demonstration, if a specific
        # gateway token needs to be associated, encrypt it.
        # In a real scenario, you'd send this token directly to the payment gateway.
        encrypted_payment_token = self._encrypt_data(payment_request.payment_token)

        # --- Step 2: Simulate interaction with a Third-Party Payment Gateway ---
        # In a real application, you'd make an actual HTTP POST request to the payment gateway's API.
        # Example using requests library (would need to be installed: pip install requests)
        # import requests
        # try:
        #     gateway_payload = {
        #         "amount": payment_request.amount,
        #         "currency": payment_request.currency,
        #         "token": payment_request.payment_token, # Send the token, not raw card data
        #         "description": payment_request.description,
        #         "metadata": {"patient_id": payment_request.patient_id, "transaction_id": transaction_id}
        #     }
        #     gateway_response = requests.post(THIRD_PARTY_PAYMENT_GATEWAY_URL, json=gateway_payload)
        #     gateway_response.raise_for_status() # Raise an exception for HTTP errors
        #     gateway_result = gateway_response.json()
        #
        #     if gateway_result.get('status') == 'success': # Adjust based on actual gateway response
        #         payment_status = PaymentStatus.SUCCESS
        #         gateway_response_id = gateway_result.get('id')
        #     else:
        #         payment_status = PaymentStatus.FAILED
        #         logger.error(f"Payment gateway returned failure: {gateway_result.get('message', 'Unknown error')}")
        #         # Potentially store gateway_result for debugging if sensitive data is handled
        #
        # except requests.exceptions.RequestException as e:
        #     payment_status = PaymentStatus.FAILED
        #     logger.error(f"Error communicating with payment gateway: {e}")

        # For this mock, we'll always assume success unless amount is 0 or negative
        gateway_response_id = "mock_gateway_id_" + str(uuid.uuid4())
        if payment_request.amount <= 0:
            payment_status = PaymentStatus.FAILED
            logger.warning(f"Payment failed for transaction {transaction_id}: Amount must be positive.")
        else:
            payment_status = PaymentStatus.SUCCESS
            logger.info(f"Mock payment gateway processed transaction {transaction_id} successfully.")

        # --- Step 3: Record transaction in DynamoDB ---
        item = {
            'transaction_id': {'S': transaction_id},
            'patient_id': {'S': payment_request.patient_id},
            'amount': {'N': str(payment_request.amount)}, # DynamoDB Number type
            'currency': {'S': payment_request.currency},
            'description': {'S': payment_request.description},
            'payment_method': {'S': payment_request.payment_method.value},
            'status': {'S': payment_status.value},
            'created_at': {'S': current_time.isoformat()},
            'updated_at': {'S': current_time.isoformat()},
            'gateway_response_id': {'S': gateway_response_id},
            # Store encrypted token only if necessary for a specific business process (e.g., refunds)
            # 'encrypted_payment_token': {'S': encrypted_payment_token}
        }
        if payment_request.appointment_id:
            item['appointment_id'] = {'S': payment_request.appointment_id}
        if payment_request.pharmacy_order_id:
            item['pharmacy_order_id'] = {'S': payment_request.pharmacy_order_id}

        try:
            self.dynamodb.put_item(
                TableName=self.table_name,
                Item=item,
                ConditionExpression="attribute_not_exists(transaction_id)" # Ensure unique ID
            )
            created_payment_record = self._dynamodb_item_to_payment_response(item)
            logger.info(f"Payment transaction {transaction_id} recorded in DynamoDB with status {payment_status.value}.")
            return created_payment_record
        except self.dynamodb.exceptions.ConditionalCheckFailedException:
            logger.error(f"Transaction ID {transaction_id} already exists (highly unlikely due to UUID).")
            raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail="Transaction ID conflict.")
        except Exception as e:
            logger.error(f"Error recording payment transaction {transaction_id} in DynamoDB: {e}")
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Failed to record payment transaction: {e}")

    def get_payment_transaction(self, transaction_id: str) -> Optional[PaymentResponse]:
        """
        Retrieves a single payment transaction by its ID.
        """
        try:
            response = self.dynamodb.get_item(
                TableName=self.table_name,
                Key={'transaction_id': {'S': transaction_id}}
            )
            item = response.get('Item')
            if item:
                return self._dynamodb_item_to_payment_response(item)
            return None
        except Exception as e:
            logger.error(f"Error getting payment transaction {transaction_id}: {e}")
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Failed to retrieve payment transaction: {e}")

    def get_patient_payments(self, patient_id: str) -> List[PaymentResponse]:
        """
        Retrieves all payment transactions for a given patient using a GSI.
        """
        try:
            response = self.dynamodb.query(
                TableName=self.table_name,
                IndexName='patient_id-index', # Ensure this GSI exists
                KeyConditionExpression='patient_id = :patient_id',
                ExpressionAttributeValues={':patient_id': {'S': patient_id}}
            )
            payments = [self._dynamodb_item_to_payment_response(item) for item in response.get('Items', [])]
            logger.info(f"Retrieved {len(payments)} payments for patient {patient_id}.")
            return payments
        except Exception as e:
            logger.error(f"Error getting payments for patient {patient_id}: {e}")
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Failed to retrieve patient payments: {e}")

    def update_payment_status(self, transaction_id: str, new_status: PaymentStatus) -> PaymentResponse:
        """
        Updates the status of an existing payment transaction (e.g., for refunds or manual adjustments).
        """
        current_time = datetime.now().isoformat()
        try:
            response = self.dynamodb.update_item(
                TableName=self.table_name,
                Key={'transaction_id': {'S': transaction_id}},
                UpdateExpression="SET #s = :new_status, updated_at = :updated_at",
                ExpressionAttributeNames={'#s': 'status'},
                ExpressionAttributeValues={
                    ':new_status': {'S': new_status.value},
                    ':updated_at': {'S': current_time}
                },
                ReturnValues="ALL_NEW"
            )
            updated_item = response.get('Attributes')
            if not updated_item:
                logger.warning(f"Transaction {transaction_id} not found for status update.")
                raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Transaction not found.")

            updated_payment = self._dynamodb_item_to_payment_response(updated_item)
            logger.info(f"Transaction {transaction_id} status updated to {new_status.value}.")
            return updated_payment
        except HTTPException:
            raise # Re-raise if it's already an HTTPException
        except Exception as e:
            logger.error(f"Error updating status for transaction {transaction_id}: {e}")
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Failed to update payment status: {e}")

# --- FastAPI Application Setup ---

app = FastAPI(
    title="NINC Payment Microservice",
    description="API for processing and managing patient payments.",
    version="1.0.0"
)

# Initialize service instances
payment_service = PaymentService()

# --- API Endpoints ---

@app.post("/payments", response_model=PaymentResponse, status_code=status.HTTP_201_CREATED)
async def create_new_payment(payment_request: PaymentRequest):
    """
    Initiates a new payment transaction.
    The 'payment_token' is expected to be a secure token from a client-side payment gateway SDK.
    """
    return payment_service.process_payment(payment_request)

@app.get("/payments/{transaction_id}", response_model=PaymentResponse)
async def get_single_payment_transaction(transaction_id: str):
    """
    Retrieves a single payment transaction by its ID.
    """
    transaction = payment_service.get_payment_transaction(transaction_id)
    if not transaction:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Payment transaction not found")
    return transaction

@app.get("/payments/patient/{patient_id}", response_model=List[PaymentResponse])
async def get_patient_all_payments(patient_id: str):
    """
    Retrieves all payment transactions for a specific patient.
    """
    return payment_service.get_patient_payments(patient_id)

@app.put("/payments/{transaction_id}/status", response_model=PaymentResponse)
async def update_payment_transaction_status(transaction_id: str, new_status: PaymentStatus):
    """
    Updates the status of an existing payment transaction (e.g., for refunds or manual adjustments).
    """
    return payment_service.update_payment_status(transaction_id, new_status)

# --- Example DynamoDB Table Creation and GSI Commands ---
# You would run these AWS CLI commands or use CloudFormation/Terraform to set up your DynamoDB table.
"""
# Create the main Payments table
aws dynamodb create-table \
    --table-name NINCPayments \
    --attribute-definitions \
        AttributeName=transaction_id,AttributeType=S \
        AttributeName=patient_id,AttributeType=S \
        AttributeName=created_at,AttributeType=S \
    --key-schema \
        AttributeName=transaction_id,KeyType=HASH \
    --billing-mode PAY_PER_REQUEST \
    --global-secondary-indexes \
        '[
            {
                "IndexName": "patient_id-index",
                "KeySchema": [
                    {"AttributeName": "patient_id", "KeyType": "HASH"}
                ],
                "Projection": {
                    "ProjectionType": "ALL"
                },
                "ProvisionedThroughput": {
                    "ReadCapacityUnits": 5,
                    "WriteCapacityUnits": 5
                }
            }
        ]'

# Create an AWS KMS Key (Customer Managed Key - CMK)
# This is a one-time setup for KMS key creation
# aws kms create-key --description "NINC Payment Encryption Key"
# aws kms create-alias --alias-name alias/ninc-payment-encryption-key --target-key-id <your-kms-key-arn>
# Ensure the IAM role used by this microservice has kms:Encrypt and kms:Decrypt permissions on this key.
"""

# To run this FastAPI application locally:
# 1. Install dependencies: pip install fastapi uvicorn "python-dotenv[extra]" boto3 pydantic
# 2. Create a .env file with your AWS credentials/endpoints and KMS Key ID:
#    AWS_REGION=us-east-1
#    PAYMENTS_TABLE_NAME=NINCPayments
#    KMS_KEY_ID=alias/ninc-payment-encryption-key # Or ARN
#    # THIRD_PARTY_PAYMENT_GATEWAY_URL=https://api.stripe.com/v1/charges (if using a real gateway)
# 3. Ensure your AWS CLI is configured with credentials that have access to DynamoDB and KMS.
# 4. Run the application: uvicorn payment_service:app --reload --port 8002
# 5. Access the API documentation at http://127.0.0.1:8002/docs


#################################################################
#Code Description:
#################################################################

# Code Description
# This Python code defines a FastAPI microservice for handling patient payments.
# It's designed to process payment requests, interact with a third-party payment gateway (simulated here), 
# store transaction details in AWS DynamoDB, and encrypt sensitive data using AWS KMS.

# Key Components
# Imports and Setup
# from fastapi import FastAPI, HTTPException, status
# from pydantic import BaseModel, Field
# import boto3
# import os
# import uuid
# import json
# import logging
# from datetime import datetime
# from typing import Optional, List, Dict, Any, Union
# from enum import Enum

# # Configure logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
# logger = logging.getLogger(__name__)
# Use code with caution
# This section imports necessary libraries.

# fastapi, HTTPException, status: For building the web API.
# pydantic, BaseModel, Field: For data validation and serialization.
# boto3: The AWS SDK for Python, used to interact with DynamoDB and KMS.
# os: To read environment variables for configuration.
# uuid: To generate unique transaction IDs.
# json: For potential JSON handling (though not explicitly used for request/response body parsing which FastAPI handles).
# logging: For logging information and errors.
# datetime: To work with timestamps.
# typing, Optional, List, Dict, Any, Union: For type hinting, improving code readability and maintainability.
# enum, Enum: To define enumerations for payment status and method.
# logging.basicConfig and logger: Sets up basic logging configuration to print messages to the console.
# Configuration
# # --- Configuration ---
# AWS_REGION = os.getenv("AWS_REGION", "us-east-1")
# PAYMENTS_TABLE_NAME = os.getenv("PAYMENTS_TABLE_NAME", "NINCPayments")
# # Assume a third-party payment gateway integration.
# # In a real scenario, this would be the actual API endpoint for Stripe, PayPal, etc.
# # For demonstration, we'll simulate it.
# THIRD_PARTY_PAYMENT_GATEWAY_URL = os.getenv("THIRD_PARTY_PAYMENT_GATEWAY_URL", "https://api.thirdpartypayment.com/process")

# # AWS KMS Key ID for encrypting sensitive tokens (e.g., payment gateway tokens)
# # This should be an alias (alias/ninc-payment-encryption-key) or ARN of a customer-managed KMS key.
# KMS_KEY_ID = os.getenv("KMS_KEY_ID", "alias/ninc-payment-encryption-key")
# Use code with caution
# This section defines configuration variables, typically read from environment variables using os.getenv. This allows for easy configuration without changing the code itself. Default values are provided if environment variables are not set.

# AWS_REGION: The AWS region where services are deployed.
# PAYMENTS_TABLE_NAME: The name of the DynamoDB table storing payment transactions.
# THIRD_PARTY_PAYMENT_GATEWAY_URL: A placeholder URL for the external payment gateway API. In a real application, this would be the actual endpoint (like Stripe or PayPal).
# KMS_KEY_ID: The ID or ARN of the AWS KMS key used for encryption.
# Enums
# # --- Enums ---
# class PaymentStatus(str, Enum):
#     PENDING = "pending"
#     SUCCESS = "success"
#     FAILED = "failed"
#     REFUNDED = "refunded"

# class PaymentMethod(str, Enum):
#     CREDIT_CARD = "credit_card"
#     DEBIT_CARD = "debit_card"
#     PAYPAL = "paypal"
#     APPLE_PAY = "apple_pay"
# Use code with caution
# Enumerations (Enum) are defined to provide a set of named constants for PaymentStatus and PaymentMethod. Using Enums makes the code more readable and prevents typos when referring to these values.

# Pydantic Models
# # --- Pydantic Models for Data Validation and Serialization ---

# class PaymentRequest(BaseModel):
#     """
#     Model for initiating a new payment.
#     Note: Raw sensitive payment data (e.g., full credit card number) should NOT
#     be handled directly by this microservice. It should come tokenized from the frontend
#     or be handled directly by the payment gateway.
#     For this example, 'payment_token' is a placeholder for a token generated by the client-side SDK
#     of a payment gateway.
#     """
#     patient_id: str = Field(..., description="ID of the patient making the payment.")
#     amount: float = Field(..., gt=0, description="Amount of the payment.")
#     currency: str = Field("USD", description="Currency of the payment (e.g., USD, EUR).")
#     description: str = Field(..., description="Description of the payment (e.g., 'Consultation fee').")
#     appointment_id: Optional[str] = Field(None, description="Optional: ID of the associated appointment.")
#     pharmacy_order_id: Optional[str] = Field(None, description="Optional: ID of the associated pharmacy order.")
#     payment_method: PaymentMethod = Field(..., description="Method of payment.")
#     # This token would be generated by a client-side SDK (e.g., Stripe.js) and securely
#     # passed to the backend. The backend never sees the raw card details.
#     payment_token: str = Field(..., description="Secure token from payment gateway's client-side SDK.")

# class PaymentResponse(BaseModel):
#     """
#     Model for returning payment transaction details.
#     """
#     transaction_id: str
#     patient_id: str
#     amount: float
#     currency: str
#     description: str
#     payment_method: PaymentMethod
#     status: PaymentStatus
#     appointment_id: Optional[str] = None
#     pharmacy_order_id: Optional[str] = None
#     gateway_response_id: Optional[str] = Field(None, description="ID returned by the third-party payment gateway.")
#     created_at: datetime
#     updated_at: datetime
# Use code with caution
# Pydantic models are used to define the structure and validate incoming request data (PaymentRequest) and outgoing response data (PaymentResponse).

# BaseModel: The base class for creating Pydantic models.
# Field: Used to add extra information to model fields, like descriptions and validation constraints (gt=0 for amount).
# Optional: Indicates that a field can be None.
# These models ensure that data conforms to expected types and formats, providing automatic data validation and documentation.
# AWS Service Clients
# # --- AWS Service Clients ---

# def get_dynamodb_client():
#     """
#     Initializes and returns a DynamoDB client.
#     """
#     try:
#         return boto3.client('dynamodb', region_name=AWS_REGION)
#     except Exception as e:
#         logger.error(f"Error initializing DynamoDB client: {e}")
#         raise

# def get_kms_client():
#     """
#     Initializes and returns an KMS client.
#     """
#     try:
#         return boto3.client('kms', region_name=AWS_REGION)
#     except Exception as e:
#         logger.error(f"Error initializing KMS client: {e}")
#         raise
# Use code with caution
# These functions initialize and return clients for interacting with AWS services:

# get_dynamodb_client(): Creates and returns a boto3 client for DynamoDB. This client is used for database operations (saving and retrieving payment records).
# get_kms_client(): Creates and returns a boto3 client for KMS. This client is used for encrypting and decrypting sensitive data. Error handling is included to log issues during client initialization.
# Service Class for Data Operations
# # --- Service Class for Data Operations ---

# class PaymentService:
#     """
#     Handles payment operations, interacts with DynamoDB, and simulates payment gateway interaction.
#     Encrypts sensitive tokens using KMS.
#     """
#     def __init__(self):
#         self.dynamodb = get_dynamodb_client()
#         self.kms = get_kms_client()
#         self.table_name = PAYMENTS_TABLE_NAME
#         self.kms_key_id = KMS_KEY_ID

#     def _dynamodb_item_to_payment_response(self, item: Dict[str, Any]) -> PaymentResponse:
#         """
#         Converts a DynamoDB item dictionary to a PaymentResponse Pydantic model.
#         """
#         try:
#             return PaymentResponse(
#                 transaction_id=item['transaction_id']['S'],
#                 patient_id=item['patient_id']['S'],
#                 amount=float(item['amount']['N']),
#                 currency=item['currency']['S'],
#                 description=item['description']['S'],
#                 payment_method=PaymentMethod(item['payment_method']['S']),
#                 status=PaymentStatus(item['status']['S']),
#                 appointment_id=item.get('appointment_id', {}).get('S'),
#                 pharmacy_order_id=item.get('pharmacy_order_id', {}).get('S'),
#                 gateway_response_id=item.get('gateway_response_id', {}).get('S'),
#                 created_at=datetime.fromisoformat(item['created_at']['S']),
#                 updated_at=datetime.fromisoformat(item['updated_at']['S'])
#             )
#         except KeyError as e:
#             logger.error(f"Missing key in DynamoDB item: {e}. Item: {item}")
#             raise ValueError(f"Invalid DynamoDB item format: {e}")
#         except Exception as e:
#             logger.error(f"Error converting DynamoDB item to PaymentResponse: {e}. Item: {item}")
#             raise

#     def _encrypt_data(self, plaintext: str) -> str:
#         """
#         Encrypts plaintext data using AWS KMS.
#         Returns the ciphertext as a base64 encoded string.
#         """
#         try:
#             response = self.kms.encrypt(
#                 KeyId=self.kms_key_id,
#                 Plaintext=plaintext.encode('utf-8')
#             )
#             # Boto3 returns bytes for CiphertextBlob, convert to base64 string for storage
#             return response['CiphertextBlob'].decode('base64')
#         except Exception as e:
#             logger.error(f"Error encrypting data with KMS: {e}")
#             raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Failed to encrypt sensitive data.")

#     def _decrypt_data(self, ciphertext_b64: str) -> str:
#         """
#         Decrypts base64 encoded ciphertext using AWS KMS.
#         Returns the original plaintext string.
#         """
#         try:
#             # Decode base64 string back to bytes
#             ciphertext_blob = ciphertext_b64.encode('base64')
#             response = self.kms.decrypt(
#                 CiphertextBlob=ciphertext_blob
#             )
#             return response['Plaintext'].decode('utf-8')
#         except Exception as e:
#             logger.error(f"Error decrypting data with KMS: {e}")
#             raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Failed to decrypt sensitive data.")

#     def process_payment(self, payment_request: PaymentRequest) -> PaymentResponse:
#         """
#         Processes a payment by simulating interaction with a third-party gateway
#         and recording the transaction in DynamoDB.
#         """
#         transaction_id = str(uuid.uuid4())
#         current_time = datetime.now()
#         payment_status = PaymentStatus.PENDING # Initial status

#         # --- Step 1: Encrypt sensitive token before potentially storing or processing ---
#         # While the full token ideally isn't stored, for demonstration, if a specific
#         # gateway token needs to be associated, encrypt it.
#         # In a real scenario, you'd send this token directly to the payment gateway.
#         encrypted_payment_token = self._encrypt_data(payment_request.payment_token)

#         # --- Step 2: Simulate interaction with a Third-Party Payment Gateway ---
#         # In a real application, you'd make an actual HTTP POST request to the payment gateway's API.
#         # Example using requests library (would need to be installed: pip install requests)
#         # import requests
#         # try:
#         #     gateway_payload = {
#         #         "amount": payment_request.amount,
#         #         "currency": payment_request.currency,
#         #         "token": payment_request.payment_token, # Send the token, not raw card data
#         #         "description": payment_request.description,
#         #         "metadata": {"patient_id": payment_request.patient_id, "transaction_id": transaction_id}
#         #     }
#         #     gateway_response = requests.post(THIRD_PARTY_PAYMENT_GATEWAY_URL, json=gateway_payload)
#         #     gateway_response.raise_for_status() # Raise an exception for HTTP errors
#         #     gateway_result = gateway_response.json()
#         #
#         #     if gateway_result.get('status') == 'success': # Adjust based on actual gateway response
#         #         payment_status = PaymentStatus.SUCCESS
#         #         gateway_response_id = gateway_result.get('id')
#         #     else:
#         #         payment_status = PaymentStatus.FAILED
#         #         logger.error(f"Payment gateway returned failure: {gateway_result.get('message', 'Unknown error')}")
#         #         # Potentially store gateway_result for debugging if sensitive data is handled
#         #
#         # except requests.exceptions.RequestException as e:
#         #     payment_status = PaymentStatus.FAILED
#         #     logger.error(f"Error communicating with payment gateway: {e}")

#         # For this mock, we'll always assume success unless amount is 0 or negative
#         gateway_response_id = "mock_gateway_id_" + str(uuid.uuid4())
#         if payment_request.amount <= 0:
#             payment_status = PaymentStatus.FAILED
#             logger.warning(f"Payment failed for transaction {transaction_id}: Amount must be positive.")
#         else:
#             payment_status = PaymentStatus.SUCCESS
#             logger.info(f"Mock payment gateway processed transaction {transaction_id} successfully.")

#         # --- Step 3: Record transaction in DynamoDB ---
#         item = {
#             'transaction_id': {'S': transaction_id},
#             'patient_id': {'S': payment_request.patient_id},
#             'amount': {'N': str(payment_request.amount)}, # DynamoDB Number type
#             'currency': {'S': payment_request.currency},
#             'description': {'S': payment_request.description},
#             'payment_method': {'S': payment_request.payment_method.value},
#             'status': {'S': payment_status.value},
#             'created_at': {'S': current_time.isoformat()},
#             'updated_at': {'S': current_time.isoformat()},
#             'gateway_response_id': {'S': gateway_response_id},
#             # Store encrypted token only if necessary for a specific business process (e.g., refunds)
#             # 'encrypted_payment_token': {'S': encrypted_payment_token}
#         }
#         if payment_request.appointment_id:
#             item['appointment_id'] = {'S': payment_request.appointment_id}
#         if payment_request.pharmacy_order_id:
#             item['pharmacy_order_id'] = {'S': payment_request.pharmacy_order_id}

#         try:
#             self.dynamodb.put_item(
#                 TableName=self.table_name,
#                 Item=item,
#                 ConditionExpression="attribute_not_exists(transaction_id)" # Ensure unique ID
#             )
#             created_payment_record = self._dynamodb_item_to_payment_response(item)
#             logger.info(f"Payment transaction {transaction_id} recorded in DynamoDB with status {payment_status.value}.")
#             return created_payment_record
#         except self.dynamodb.exceptions.ConditionalCheckFailedException:
#             logger.error(f"Transaction ID {transaction_id} already exists (highly unlikely due to UUID).")
#             raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail="Transaction ID conflict.")
#         except Exception as e:
#             logger.error(f"Error recording payment transaction {transaction_id} in DynamoDB: {e}")
#             raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Failed to record payment transaction: {e}")

#     def get_payment_transaction(self, transaction_id: str) -> Optional[PaymentResponse]:
#         """
#         Retrieves a single payment transaction by its ID.
#         """
#         try:
#             response = self.dynamodb.get_item(
#                 TableName=self.table_name,
#                 Key={'transaction_id': {'S': transaction_id}}
#             )
#             item = response.get('Item')
#             if item:
#                 return self._dynamodb_item_to_payment_response(item)
#             return None
#         except Exception as e:
#             logger.error(f"Error getting payment transaction {transaction_id}: {e}")
#             raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Failed to retrieve payment transaction: {e}")

#     def get_patient_payments(self, patient_id: str) -> List[PaymentResponse]:
#         """
#         Retrieves all payment transactions for a given patient using a GSI.
#         """
#         try:
#             response = self.dynamodb.query(
#                 TableName=self.table_name,
#                 IndexName='patient_id-index', # Ensure this GSI exists
#                 KeyConditionExpression='patient_id = :patient_id',
#                 ExpressionAttributeValues={':patient_id': {'S': patient_id}}
#             )
#             payments = [self._dynamodb_item_to_payment_response(item) for item in response.get('Items', [])]
#             logger.info(f"Retrieved {len(payments)} payments for patient {patient_id}.")
#             return payments
#         except Exception as e:
#             logger.error(f"Error getting payments for patient {patient_id}: {e}")
#             raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Failed to retrieve patient payments: {e}")

#     def update_payment_status(self, transaction_id: str, new_status: PaymentStatus) -> PaymentResponse:
#         """
#         Updates the status of an existing payment transaction (e.g., for refunds or manual adjustments).
#         """
#         current_time = datetime.now().isoformat()
#         try:
#             response = self.dynamodb.update_item(
#                 TableName=self.table_name,
#                 Key={'transaction_id': {'S': transaction_id}},
#                 UpdateExpression="SET #s = :new_status, updated_at = :updated_at",
#                 ExpressionAttributeNames={'#s': 'status'},
#                 ExpressionAttributeValues={
#                     ':new_status': {'S': new_status.value},
#                     ':updated_at': {'S': current_time}
#                 },
#                 ReturnValues="ALL_NEW"
#             )
#             updated_item = response.get('Attributes')
#             if not updated_item:
#                 logger.warning(f"Transaction {transaction_id} not found for status update.")
#                 raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Transaction not found.")

#             updated_payment = self._dynamodb_item_to_payment_response(updated_item)
#             logger.info(f"Transaction {transaction_id} status updated to {new_status.value}.")
#             return updated_payment
#         except HTTPException:
#             raise # Re-raise if it's already an HTTPException
#         except Exception as e:
#             logger.error(f"Error updating status for transaction {transaction_id}: {e}")
#             raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Failed to update payment status: {e}")
# Use code with caution
# The PaymentService class encapsulates the core business logic for payment operations.

# The __init__ method initializes the DynamoDB and KMS clients and stores the table name and KMS key ID.
# _dynamodb_item_to_payment_response: A helper method to convert the format of data returned by DynamoDB (which includes data types like {'S': 'string'} and {'N': 'number string'}) into the PaymentResponse Pydantic model.
# _encrypt_data: Uses the KMS client to encrypt sensitive plaintext data (like payment tokens) and returns the ciphertext encoded in Base64.
# _decrypt_data: Uses the KMS client to decrypt Base64 encoded ciphertext back into plaintext.
# process_payment: This is the main method for initiating a new payment. It generates a unique transaction ID, encrypts the incoming payment token (demonstration purposes; often the token goes directly to the gateway), simulates interaction with the third-party gateway, determines the final payment status, and then saves the transaction details to the DynamoDB table. It uses a ConditionExpression to prevent overwriting an existing item with the same transaction ID.
# get_payment_transaction: Retrieves a single payment record from DynamoDB based on its transaction_id.
# get_patient_payments: Retrieves all payment records for a specific patient_id from DynamoDB. It assumes the existence of a Global Secondary Index (GSI) named 'patient_id-index' on the patient_id attribute to allow for efficient querying by patient ID.
# update_payment_status: Updates the status and updated_at fields for an existing payment transaction in DynamoDB.
# FastAPI Application Setup
# # --- FastAPI Application Setup ---

# app = FastAPI(
#     title="NINC Payment Microservice",
#     description="API for processing and managing patient payments.",
#     version="1.0.0"
# )

# # Initialize service instances
# payment_service = PaymentService()
# Use code with caution
# An instance of the FastAPI class is created, named app. This object will define the web application. The title, description, and version parameters help generate automatic API documentation.
# An instance of the PaymentService class is created. This instance holds the logic for interacting with AWS services and processing payments.
# API Endpoints
# # --- API Endpoints ---

# @app.post("/payments", response_model=PaymentResponse, status_code=status.HTTP_201_CREATED)
# async def create_new_payment(payment_request: PaymentRequest):
#     """
#     Initiates a new payment transaction.
#     The 'payment_token' is expected to be a secure token from a client-side payment gateway SDK.
#     """
#     return payment_service.process_payment(payment_request)

# @app.get("/payments/{transaction_id}", response_model=PaymentResponse)
# async def get_single_payment_transaction(transaction_id: str):
#     """
#     Retrieves a single payment transaction by its ID.
#     """
#     transaction = payment_service.get_payment_transaction(transaction_id)
#     if not transaction:
#         raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Payment transaction not found")
#     return transaction

# @app.get("/payments/patient/{patient_id}", response_model=List[PaymentResponse])
# async def get_patient_all_payments(patient_id: str):
#     """
#     Retrieves all payment transactions for a specific patient.
#     """
#     return payment_service.get_patient_payments(patient_id)

# @app.put("/payments/{transaction_id}/status", response_model=PaymentResponse)
# async def update_payment_transaction_status(transaction_id: str, new_status: PaymentStatus):
#     """
#     Updates the status of an existing payment transaction (e.g., for refunds or manual adjustments).
#     """
#     return payment_service.update_payment_status(transaction_id, new_status)
# Use code with caution
# These define the API endpoints using FastAPI decorators:

# @app.post("/payments", ...): Defines a **

